*** Begin Patch
*** Update File: pmm/commitments/tracker.py
@@
 class CommitmentTracker:
@@
-    def _rebind_commitments_on_identity_adopt(self, *, identity_adopt_event_id: str) -> None:
-        """(legacy stub) Rebinds commitments when identity is adopted."""
-        # Previous behavior was non-idempotent and emitted multiple projections.
-        # This was also missing linkage to the adopting event id.
-        pass
+    def _rebind_commitments_on_identity_adopt(self, *, identity_adopt_event_id: str) -> None:
+        """Idempotently rebind open commitments to the newly adopted identity.
+
+        Guarantees:
+          - Emits at most one `commitment_rebind` per (commitment_id, identity_adopt_event_id).
+          - Emits at most one `identity_projection` summary per identity_adopt_event_id,
+            aggregating all rebinds performed for that adoption (even across retries).
+        """
+        log = self._eventlog  # expected to be injected in __init__
+        open_commitments = self._list_open_commitments()  # returns iterable of (cid, meta, data)
+
+        # Discover already-emitted rebinds/projection for idempotency.
+        prior_rebinds = {
+            e["data"].get("commitment_id")
+            for e in log.read(type="commitment_rebind", where={"identity_adopt_event_id": identity_adopt_event_id})
+        }
+        projection_already_exists = any(
+            True for _ in log.read(type="identity_projection", where={"identity_adopt_event_id": identity_adopt_event_id})
+        )
+
+        emitted = []
+        for cid, meta, data in open_commitments:
+            if cid in prior_rebinds:
+                continue
+            payload = {
+                "commitment_id": cid,
+                "previous_identity_id": data.get("identity_id"),
+                "new_identity_id": self._current_identity_id(),
+                "identity_adopt_event_id": identity_adopt_event_id,
+            }
+            log.append(type="commitment_rebind", data=payload, tags={"idempotent_key": f"rebind:{cid}:{identity_adopt_event_id}"})
+            emitted.append(payload)
+
+        # Emit one projection summarizing rebinds for this adoption (once).
+        if emitted and not projection_already_exists:
+            summary = {
+                "identity_adopt_event_id": identity_adopt_event_id,
+                "rebounds": [{"commitment_id": p["commitment_id"], "to_identity": p["new_identity_id"]} for p in emitted],
+                "count": len(emitted),
+            }
+            log.append(type="identity_projection", data=summary, tags={"idempotent_key": f"identity_projection:{identity_adopt_event_id}"})
+
*** End Patch
